## 1.2 PCB概念——进程控制块

### 1.2.1 task_struct结构

	定义位置：/usr/src/linux-headers/include/linux/sched.h

### 1.2.2 files_struct结构体
	
	相当于一张表，或者指针，文件描述符表
	FILE *		fopen("abc")

## 1.3 open/close

### 1.3.1 文件描述符

	一个京城默认打开3个文件描述符
	STDIN_FILENO 0
	STDOUT_FILENO 1
	STDERR_FILENO 2

	open函数可以打开或者创建一个文件
使用open函数，需要包含以下三个头文件
	#include <sys/types.h>
	#include <sys/stat.h>
	#include <fcntl.h>
	
	最后的可变参数可以是0个或1个,由flags参数中的标志位决定,见下面的详细说明。
	pathname参数是要打开或创建的文件名,和fopen一样,pathname既可以是相对路径也可以是绝对路径。flags参数有一系列常数值可供选择,可以同时选择多个常数用按位或运算符连接起来,所以这些常数的宏定义都以O_开头,表示or。
必选项:以下三个常数中必须指定一个,且仅允许指定一个。
* O_RDONLY 只读打开
* O_WRONLY 只写打开
* O_RDWR 可读可写打开
以下可选项可以同时指定0个或多个,和必选项按位或起来作为flags参数。可选项有很多,这里只介绍一部分,其它选项可参考open(2)的Man Page:
* O_APPEND 表示追加。如果文件已有内容,这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。
* O_CREAT 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode,表示该文件的访问权限。
* O_EXCL 如果同时指定了O_CREAT,并且文件已存在,则出错返回。
* O_TRUNC 如果文件已存在,并且以只写或可读可写方式打开,则将其长度截断(Trun-cate)为0字节。
* O_NONBLOCK 对于设备文件,以O_NONBLOCK方式打开可以做非阻塞I/O(Nonblock I/O),非阻塞I/O在下一节详细讲解。
	open函数和C标准I/O库的fopen函数细微区别在于：
		以可写方式fopen一个文件时，如果文件不存在则会自动创建，而open一个文件时必须使用O_CREAT才会创建文件，否则文件不存在就出错返回。
		以w或者w+方式fopen一个文件时，如果文件存在就截断为0字节，而open一个文件必须明确指定O_TRUNC才会截断文件，否则在原来的数据上改写。
		以三个参数mode指定文件权限，可以用八进制数表示，比如0644表示-rw-r--r--,也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示。要注意的是，文件权限由open的mode参数和当前进程的umask共同决定。

	close函数
	
	最大文件打开个数
	默认一个进程最多可以打开1024个文件，可以使用
	cat /proc/sys/fs/file-max
	通过ulimit -a可以查看和修改文件打开个数
	ulimit -n 4096

## 1.4 read/write

	#include <unistd.h>

	ssize_t read(int fd, void *buf, size_t count);
	返回值：成功返回读取的字节数，出错则返回-1并设置errno，如果在调用read之前已经到达文件末尾，则这次read返回0；
	ssize_t 有符号int，size_t 无符号int
	参数count是请求读取的字节数,读上来的数据保存在缓冲区buf中,同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同,这个读写位置是记在内核中的,而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置。比如用fgetc读一个字节,fgetc有可能从内核中预读1024个字节到I/O缓冲区中,再返回第一个字节,这时该文件在内核中记录的读写位置是1024,而在FILE结构体中记录的读写位置是1。注意返回值类型是ssize_t,表示有符号的size_t,这样既可以返回正的字节数、0(表示到达文件末尾)也可以返回负值-1(表示出错)。read函数返回时,返回值说明了buf中前多少个字节是刚读上来的。有些情况下,实际读到的字节数(返回值)会小于请求读的字节数count,例如:
	读常规文件时,在读到count个字节之前已到达文件末尾。例如,距文件末尾还有30个字节而请求读100个字节,则read返回30,下次read将返回0。
	从终端设备读,通常以行为单位,读到换行符就返回了。
	从网络读,根据不同的传输层协议和内核缓存机制,返回值可能小于请求的字节数,后面socket编程部分会详细讲解。

	write函数向打开的设备或文件中写数据。
	#include <unistd.h>

	ssize_t write(int fd, void *buf, size_t count);
	返回值：成功返回写入的字节数，出错返回-1并设置errno
	写常规文件时,write的返回值通常等于请求写的字节数count,而向终端设备或网络写则不一定。

## 1.5 阻塞和非阻塞

	读常规文件是不会阻塞的，不管读多少字节，read都会在有限时间内返回。从终端设备和网络读则不一定，如果从终端输入的数据 没有换行符，调用read读终端的设备就会阻塞，如果网络上没有接收到数据包，调用read从网络读就会阻塞，至于阻塞多长时间是不确定的，如果一直没有数据到达就一直阻塞在哪里。同样，写常规文件也是不会阻塞的，而向终端设备或网络写则不一定。


